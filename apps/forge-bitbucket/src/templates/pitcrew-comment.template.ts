import { createHash } from "crypto";
import { StoredPullRequest } from "../models/stored-pr";
import { InternalPr } from "../models/internal-pr";

/**
 * PitCrew Comment Template
 * Generates Markdown comments for Pull Requests with risk analysis and actionable recommendations.
 */

/**
 * Build a PitCrew AI comment for a Pull Request.
 * 
 * @param pr - Stored or Internal PR object
 * @returns Markdown-formatted comment
 */
export function buildPitCrewComment(pr: StoredPullRequest | InternalPr): string {
    // Determine risk data source
    const riskScore = "risk" in pr ? pr.risk.score : pr.riskScore ?? 0;
    const riskColor = "risk" in pr ? pr.risk.color : pr.riskColor ?? "green";
    const riskFactors = "risk" in pr ? pr.risk.factors : pr.riskFactors ?? [];

    const filesChanged = "diff" in pr ? pr.diff.filesChanged : pr.modifiedFiles?.length ?? 0;
    const linesAdded = "diff" in pr ? pr.diff.linesAdded : pr.totalLinesAdded ?? 0;
    const linesRemoved = "diff" in pr ? pr.diff.linesRemoved : pr.totalLinesRemoved ?? 0;
    const linesChanged = linesAdded + linesRemoved;

    const colorBadge = getRiskBadge(riskColor);

    let markdown = `## ðŸŽï¸ PitCrew AI Report ${colorBadge}\n\n`;

    markdown += `**Risk Score:** \`${riskScore}/100\` (${riskColor.toUpperCase()})\n\n`;

    markdown += `### ðŸ“Š Change Summary\n\n`;
    markdown += `- **Files Changed:** ${filesChanged}\n`;
    markdown += `- **Lines:** +${linesAdded} / -${linesRemoved} (${linesChanged} total)\n\n`;

    if (riskFactors.length > 0) {
        markdown += `### âš ï¸ Risk Factors & Recommendations\n\n`;

        const recommendations = generateActionableRecommendations(riskFactors, pr);
        recommendations.forEach((rec) => {
            markdown += `- **${rec.factor}**\n  â†’ ${rec.action}\n\n`;
        });
    } else {
        markdown += `### âœ… No Major Risk Factors Detected\n\n`;
        markdown += `This PR looks good! Keep up the great work.\n\n`;
    }

    markdown += `---\n\n`;
    markdown += `<sub>`;
    markdown += `Last analyzed: ${new Date().toISOString()} | `;
    markdown += `Generated by PitCrew AI`;
    markdown += `</sub>\n`;

    return markdown;
}

/**
 * Get a visual badge for the risk color.
 */
function getRiskBadge(color: "green" | "yellow" | "red"): string {
    switch (color) {
        case "green":
            return "ðŸŸ¢";
        case "yellow":
            return "ðŸŸ¡";
        case "red":
            return "ðŸ”´";
        default:
            return "âšª";
    }
}

/**
 * Generate actionable recommendations from risk factors.
 */
function generateActionableRecommendations(
    factors: string[],
    pr: StoredPullRequest | InternalPr
): Array<{ factor: string; action: string }> {
    const recommendations: Array<{ factor: string; action: string }> = [];

    factors.forEach((factor) => {
        const lowerFactor = factor.toLowerCase();

        if (lowerFactor.includes("no reviewers")) {
            recommendations.push({
                factor: "No Reviewers Assigned",
                action: "Assign 1-2 reviewers familiar with the changed code.",
            });
        } else if (lowerFactor.includes("critical file")) {
            const criticalCount = extractNumber(factor);
            recommendations.push({
                factor: `${criticalCount} Critical File(s) Touched`,
                action: "Request senior review for core/auth/infra changes.",
            });
        } else if (lowerFactor.includes("no tests")) {
            recommendations.push({
                factor: "No Tests Detected",
                action: "Add or update tests to cover logic changes.",
            });
        } else if (lowerFactor.includes("off-hours")) {
            recommendations.push({
                factor: "Off-hours Submission",
                action: "Review carefullyâ€”changes made outside normal hours may have less oversight.",
            });
        } else if (lowerFactor.includes("files:") || lowerFactor.includes("lines:")) {
            return;
        } else if (lowerFactor.includes("signals:")) {
            return;
        } else if (lowerFactor.includes("docs-only")) {
            recommendations.push({
                factor: "Documentation-Only Changes",
                action: "Quick reviewâ€”low risk of breaking changes.",
            });
        } else if (lowerFactor.includes("tests-only")) {
            recommendations.push({
                factor: "Tests-Only Changes",
                action: "Great! Tests improve code quality.",
            });
        } else if (lowerFactor.includes("very small pr")) {
            recommendations.push({
                factor: "Very Small PR (Risk Floor Applied)",
                action: "Small changes are easier to reviewâ€”keep it up!",
            });
        } else {
            recommendations.push({
                factor: factor,
                action: "Review this aspect carefully.",
            });
        }
    });

    return recommendations.slice(0, 6);
}

/**
 * Extract a number from a string (e.g., "2 Critical Files" â†’ 2)
 */
function extractNumber(str: string): number {
    const match = str.match(/\d+/);
    return match ? parseInt(match[0], 10) : 0;
}

/**
 * Compute a fingerprint for a PR comment to detect material changes.
 * This hash excludes timestamps to avoid infinite update loops.
 * 
 * @param pr - Stored or Internal PR object
 * @returns SHA256 hash representing the comment content
 */
export function computeCommentFingerprint(pr: StoredPullRequest | InternalPr): string {
    const fingerprintData = {
        riskScore: "risk" in pr ? pr.risk.score : pr.riskScore,
        riskColor: "risk" in pr ? pr.risk.color : pr.riskColor,
        riskFactors: "risk" in pr ? pr.risk.factors.sort() : (pr.riskFactors ?? []).sort(),

        filesChanged: "diff" in pr ? pr.diff.filesChanged : pr.modifiedFiles?.length,
        linesAdded: "diff" in pr ? pr.diff.linesAdded : pr.totalLinesAdded,
        linesRemoved: "diff" in pr ? pr.diff.linesRemoved : pr.totalLinesRemoved,

        criticalFilesTouched: "diff" in pr ? pr.diff.criticalFilesTouched : (pr.analysisMetrics?.criticalFilesCount ?? 0) > 0,
        testsTouched: "diff" in pr ? pr.diff.testsTouched : (pr.analysisMetrics?.testFilesCount ?? 0) > 0,
    };

    const stableJson = JSON.stringify(fingerprintData, Object.keys(fingerprintData).sort());
    const hash = createHash("sha256").update(stableJson).digest("hex");

    return hash;
}
